<launch>
    <!-- パラメータ設定セクション nodeとは独立させて書く-->
    <!-- parameters for spoofing simulation node-->
    <param name="subscribe_topic_name" value="/livox/lidar"/>
    <param name="subscribe_odometry_name" value="/odom"/>
    <param name="number_of_iterations" value="1"/>
    <param name="sample_rate" value="0.25"/>
    <param name="noise_variance" value="0.1"/>
    <param name="min_distance" value="2.5"/>
    <param name="max_distance" value="30"/>
    <param name="max_height" value="-0.8"/>
    <param name="spoofed_frame_name" value="odom"/>
    <param name="spoofing_mode" value="injection"/>
    <param name="injection_distance" value="30.0" />

    <param name="attackablity_save_dir" value="/home/rokuto/cbulid_ws/src/spoofing_sim/Attackablity_e2e_test/"/>
    <param name="trajectory_save_dir" value="/home/rokuto/cbulid_ws/src/spoofing_sim/Trajectory_e2e_test/"/>

    <!-- spoofer params -->
    <arg name="x" default="50" />
    <arg name="y" default="-5" />

    <param name="spoofing_max_distance" value="30.0"/>
    <param name="spoofer_location_x" value="$(arg x)"/>
    <param name="spoofer_location_y" value="$(arg y)"/>
    <param name="min_spoofing_angle" value="15" />
     <param name="max_spoofing_angle" value="165" />

    <!-- lidar params -->
    <param name="lidar_horizontal_resolution" value="0.15"/>
    <param name="lidar_vertical_lines" value="40"/>
    <param name="spofing_success_rate" value="0.05"/>

    <node name="node1" pkg="spoofing_sim" type="node2.py" output="screen" required="true"/>
    <node name="node2" pkg="spoofing_sim" type="odom_node.py" output="screen" required="true"/>

    <!-- arguments -->
    <arg name="nodelet_manager" default="velodyne_nodelet_manager" />
    <arg name="points_topic" default="/cloud_spoofed" />
    <!-- input clouds are transformed in odom_child_frame, and then localization is performed in that frame -->
    <!-- this is useful to match the LIDAR and IMU coodinate systems -->
    <arg name="odom_child_frame_id" default="odom" />

    <!-- optional arguments -->
    <arg name="use_imu" default="false" />
    <arg name="invert_imu_acc" default="false" />
    <arg name="invert_imu_gyro" default="false" />
    <arg name="use_global_localization" default="true" />
    <arg name="imu_topic" default="/imu/data" />
    <arg name="enable_robot_odometry_prediction" value="false" />
    <arg name="robot_odom_frame_id" value="odom" />
    <arg name="plot_estimation_errors" value="false" />

    <include file="$(find hdl_global_localization)/launch/hdl_global_localization.launch" if="$(arg use_global_localization)" />

    <!-- in case you use velodyne_driver, comment out the following line -->
    <node pkg="nodelet" type="nodelet" name="$(arg nodelet_manager)" args="manager" output="screen"/>

        <!-- globalmap_server_nodelet -->
        <node pkg="nodelet" type="nodelet" name="globalmap_server_nodelet" args="load hdl_localization/GlobalmapServerNodelet $(arg nodelet_manager)">
        <param name="globalmap_pcd" value="$(find hdl_localization)/data/benign_32c.pcd" />
        <param name="convert_utm_to_local" value="true" />
        <param name="downsample_resolution" value="0.1" />
        </node>

    <!-- hdl_localization_nodelet -->
    <node pkg="nodelet" type="nodelet" name="hdl_localization_nodelet" args="load hdl_localization/HdlLocalizationNodelet $(arg nodelet_manager)">
    <remap from="/velodyne_points" to="$(arg points_topic)" />
    <remap from="/gpsimu_driver/imu_data" to="$(arg imu_topic)" />
    <!-- odometry frame_id -->
    <param name="odom_child_frame_id" value="$(arg odom_child_frame_id)" />
    <!-- imu settings -->
    <!-- during "cool_time", imu inputs are ignored -->
    <param name="use_imu" value="$(arg use_imu)" />
    <param name="invert_acc" value="$(arg invert_imu_acc)" />
    <param name="invert_gyro" value="$(arg invert_imu_gyro)" />
    <param name="cool_time_duration" value="2.0" />
    <!-- robot odometry-based prediction -->
    <param name="enable_robot_odometry_prediction" value="$(arg enable_robot_odometry_prediction)" />
    <param name="robot_odom_frame_id" value="$(arg robot_odom_frame_id)" />
    <!-- ndt settings -->
    <!-- available reg_methods: NDT_OMP, NDT_CUDA_P2D, NDT_CUDA_D2D-->
    <param name="reg_method" value="NDT_OMP" />
    <!-- if NDT is slow for your PC, try DIRECT1 serach method, which is a bit unstable but extremely fast -->
    <param name="ndt_neighbor_search_method" value="DIRECT7" />
    <param name="ndt_neighbor_search_radius" value="2.0" />
    <param name="ndt_resolution" value="1.0" />
    <param name="downsample_resolution" value="0.1" />
    <!-- if "specify_init_pose" is true, pose estimator will be initialized with the following params -->
    <!-- otherwise, you need to input an initial pose with "2D Pose Estimate" on rviz" -->
    <param name="specify_init_pose" value="true" />
    <param name="init_pos_x" value="0.0" />
    <param name="init_pos_y" value="0.0" />
    <param name="init_pos_z" value="0.0" />
    <param name="init_ori_w" value="1.0" />
    <param name="init_ori_x" value="0.0" />
    <param name="init_ori_y" value="0.0" />
    <param name="init_ori_z" value="0.0" />

    <param name="use_global_localization" value="$(arg use_global_localization)" />
    </node>

    <node pkg="hdl_localization" type="plot_status.py" name="plot_estimation_errors" if="$(arg plot_estimation_errors)" />

</launch>